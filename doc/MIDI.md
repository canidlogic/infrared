# Infrared MIDI generation

Infrared generates standard MIDI files as output.  Infrared always uses Format 0 MIDI files with all events in a single track.  Infrared always use a delta time unit with 768 delta units per quarter note, so that delta units correspond to subquantum units, as described in detail in the documentation about timing systems.

This document describes how Infrared assembles MIDI events and sequences them all into a single track.

## Header and moment buffers

Infrared accumulates MIDI events in two buffers:  a _header buffer_ and a _moment buffer._

The header buffer is a sequence of events that will be included at the start of the track at MIDI delta time zero before any of the moment buffer events.  It is intended for certain metadata events that are supposed to be positioned at delta time zero before the MIDI performance gets started.  The order in which events are added to the header buffer will be the order the events appear at the start of the MIDI track.

The moment buffer is a set of timed events, each of which contains an event ID, a moment offset, and a MIDI event that takes place at that moment offset.

The _event ID_ is a unique integer assigned to each timed event.  The first event added to the moment buffer gets event ID 1, the second event gets ID 2, the third gets ID 3, and so forth.  The event ID is used during moment sorting to preserve the original order of events within the same moment offset, which may be significant in cases where a sequence of MIDI events must be performed in a certain order.  (For example, setting a registered control value or selecting a patch with both a bank and a program number.)

The moment offset is the subquantum offset multiplied by three, and then with an integer in range 0 to 2 added to the result to indicate the _moment part_ as follows:

    +0 = Start of moment
    +1 = Middle of moment
    +2 = End of moment

Moment offsets may be negative.

### Event range

Infrared keeps track of the _event range_ as events are added into the moment buffer.  The event range has a lower boundary and an upper boundary, both of which are subquantum time offsets.  The upper boundary is always greater than or equal to the lower boundary.

If the moment buffer is empty, the upper and lower boundaries of the event range are both zero.

If the moment buffer is not empty, the lower boundary will be the subquantum offset corresponding to the lowest moment offset of any event that has been added so far to the moment buffer.  The upper boundary will be the subquantum offset corresponding to the highest moment offset of any event that has been added so far to the moment buffer.

After all events have been added to the moment buffer, the lower boundary of the event range will become time point zero in the final MIDI sequence and all events will be rebased relative to that new time point zero.  The rebased upper boundary will then be the time point where the End Of Track message will be inserted.

In order to manually control the time point zero and the full duration of the track, you can use null events (defined later).  Null events update the event range but do not actually add any event to the track.  If you put a null event somewhere before all other events in the moment buffer, that null event will become time point zero.  If you put a null event somewhere after all other events in the moment buffer, that null event will become the End Of Track position.

The event range is also used by the tracking algorithm to determine controller change messages, as described in the documentation about graphs.  Controller change messages always use the event range as boundaries for the tracking algorithm, so the inserted events will never change the event range themselves.

### Moment sorting

The moment buffer accepts events in any order.  However, the output MIDI track requires events to be in chronological order.  _Moment sorting_ is used to sort the moment buffer into a proper chronology.

The most significant sorting order is by _ascending moment offset._  This places events in chronological order of performance time.  However, a single moment offset may have many events associated with it, so further sorting orders are required beyond the moment offset.

The second most significant sorting order is by _status byte class._  If the status byte of the event is in range 0x80 to 0xAF inclusive, then the event is a Note-Off, Note-On, or Polyphonic Key Pressure (Aftertouch) message.  These three message types are only generated by the note rendering process.

Within each moment offset, events that have a status byte in range 0x80 to 0xAF inclusive are sorted after all other events.  Furthermore, the note rendering process will assign start-of-moment to all events that turn off a note and middle-of-moment to all events that turn on a note and all aftertouch events.  This causes the output of the note rendering process to be interleaved with the rest of the events as follows:

1. Start-of-moment events
2. Note-Off events (and Note-On with velocity zero)
3. Middle-of-moment events
4. Note-On and Polyphonic Key Pressure (Aftertouch)
5. End-of-moment events

Therefore, when selecting the moment part for events, the moment part will decide where in relationship to the note-off and note-on events the event takes place.

The third most significant sorting order is by _running status._  For events with a status byte in range 0x80 to 0xAF inclusive, and events with a status byte in range 0xB0 to 0xEF inclusive, events are sorted in ascending order of status byte; however, this is done so that the status byte class ordering is not disrupted.  Events with status bytes in range 0xF0 to 0xFF inclusive are sorted as if they all had the same status byte value.  The resulting order is:

1. Status bytes 0xB0 to 0xEF, ascending order
2. Status bytes 0xF0 to 0xFF, no particular order
3. Status bytes 0x80 to 0xAF, ascending order

The running status order is designed to make best possible use of the running status byte optimization, where MIDI files do not need to repeat status bytes if they are the same.  However, running status does not apply to status bytes in range 0xF0 to 0xFF, which is why those are treated differently.

The fourth most significant sorting order is by _event ID._  For events that share the same moment offset and status bytes, their sorting order is determined by their event ID.  Furthermore, status bytes in range 0xF0 to 0xFF are considered to have the same value for this sorting step, so all status bytes in range 0xF0 to 0xFF will be sorted in event ID order regardless of their particular status byte.

The event ID sorting not only guarantees a well-defined ordering (since each event has a unique event ID), but it also guarantees that for events sharing the same moment ID and status bytes (where status bytes 0xF0 to 0xFF are considered equivalent), the ordering in the final sequence will match the order the events were added to the moment buffer.

This final ordering guarantee is important for cases where events taking place at the same time point must be performed in a specific sequence.  For example, certain control values must be set with multiple Control Change events performed in a certain order.  Each of these Control Change events will have the same moment offset and status byte, so they will end up sorted by event ID, such that their order in the final sequence matches their definition order.

Treating 0xF0 to 0xFF as equivalent in the final sorting step is necessary because sequences of system exclusives and other special message types may require the same definition order even when they use different status bytes.

### Track capping

After all events have been added to the moment buffer and they have been sorted according to moment sorting, the next step is _track capping._

MIDI files require the track to end with an End Of Track message.  The time position of this message is significant, as it determines the full duration of the performance.

Once moment sorting is complete, an End Of Track message will be appended to the buffer with a moment offset corresponding to the upper boundary of the event range with an end-of-moment moment part.  Appending after sorting ensures that the End Of Track message will be the last message in the track, thereby "capping" the track.

### Time rebasing

Following track capping, the next step is _time rebasing._  The lower boundary of the event range will be time offset zero in the MIDI track.  All moment offsets are converted into equivalent subquantum offsets, and then rebased relative to this MIDI time offset zero.  This ensures that all offsets are zero or greater.

Finally, the time offsets are converted into delta times relative to the previous time (or relative to zero if the first event in the track).  This matches the delta time system used in MIDI tracks.

### Two-pass output

Once time rebasing is complete, it is relatively straightforward to convert the header and moment buffers into the raw binary data that will be output to the MIDI file.

In order to support fully sequential output of the generated MIDI file, the track is output in two passes.  The first pass computes the total length in bytes of data within the MIDI track.  This allows the track length to be written to the track header before writing the rest of the track.  The second pass then outputs all the messages within the track.

## Selectors

MIDI events are stored in the header and moment buffers using selectors.

A _selector_ is an unsigned 32-bit integer that stores two packed fields.  The most significant byte of the selector is the status byte of the message, and the 24 least significant bits of the selector are a byte offset within a message buffer.

The _message buffer_ is a byte buffer that stores all MIDI message data besides the status bytes that are stored directly in the selector.  The selector has a byte offset where its data starts within the message buffer.

For status bytes in range 0x80 to 0xBF inclusive and range 0xE0 to 0xEF inclusive, there are always exactly two data bytes for the message at the indicated offset in the message buffer.

For status bytes in range 0xC0 to 0xDF inclusive, there is always exactly one data byte for the message at the indicated offset in the message buffer.

For status bytes 0xF0 and 0xF7, their data begins with a MIDI variable-length integer that counts how many data bytes follow the length declaration.  However, instead of directly storing the data bytes in the message buffer, the length declaration is followed by another MIDI variable-length integer that selects a blob object in the handle table (see later).  During MIDI output, this handle will be replaced with the actual binary data from the blob.

For status byte 0xFF, the first data byte is a meta-event type code.  This is followed by a MIDI variable-length integer that counts how many data bytes follow the length declaration.  If this length value is less than 8, then that number of data bytes directly follow it in the message buffer.  If the length value is greater than or equal to eight, then the actual length is eight less than the length value, and instead of directly storing the data bytes in the message buffer, there is a MIDI variable-length integer that selects a blob or text object in the handle table (see later).

The _handle table_ is an array of elements where each element is either a blob or text object pointer.  Certain messages in the message buffer store an index into this handle table instead of directly storing the data bytes in the mssage buffer, as described above.

The handle table also has a special entry type for blobs where the first byte of the blob should be skipped.  This is intended for certain system exclusive messages where the first byte is implicit.

## Interface

The MIDI module of Infrared contains the header buffer, moment buffers, message buffer, and handle table.  It is capable of writing a full standard MIDI file to output, as described in detail in earlier sections.

The interface to the MIDI module allows events to be added to the header or moment buffer, and it also provides a compilation method to generate the output MIDI file.

The compilation method merely needs a standard I/O output handle to write the MIDI file to.  Most of the MIDI module interface is dedicated to various methods for adding different kinds of MIDI events to head or moment buffers.  This final part of the documentation describes the kinds of events that the MIDI module supports.

### Null events

Null events are a special kind of event that adjust the event range when they are added to the moment buffer.  However, they do not actually add any MIDI output messages.  Adding null events to the header buffer has no effect.

### Text events

Text events are a meta-event that is included in the standard MIDI file as metadata but not actually transmitted as a MIDI message.  Text events include a text class, which is one of the following:

1. General (no specific class)
2. Copyright
3. Sequence name
4. Instrument name
5. Lyric
6. Marker
7. Cue

Text events specify their text data as a text object.

### Tempo events

Tempo events are a meta-event that is included in the standard MIDI file as metadata.  The tempo specifies the number of microseconds in a quarter note, as an integer in range 1 to 16,777,215 inclusive.

### Time signature events

Time signature events are a meta-event that is included in the standard MIDI file as metadata but do not actually affect the MIDI performance.

The time signature has a numerator and a denominator.  The numerator is an integer in range 1 to 255 inclusive.  The denominator is an integer in range 1 to 1024 inclusive that must be a power of two.

The time signature also indicates how frequently a metronome should click, in units of 1/24 a quarter note.  The range is 1 to 255 inclusive.

Infrared does not allow the MIDI quarter note to be redefined, so the number of 32nd notes in a MIDI quarter note is always set to eight.

### Key signature events

Key signature events are a meta-event that is included in the standard MIDI file as metadata but do not actually affect the MIDI performance.

The key signature stores the count of flats or the count of sharps.  The number of flats or sharps is at most seven.  A count of zero is also allowed for no accidentals in the key signature.

Furthermore, the key signature stores whether it is for a major key or a minor key.

### Custom meta events

Custom meta events are meta-events that are included in the standard MIDI file and are intended for the sequencer rather than transmission.  They correspond to Sequencer-Specific Meta-Event in the MIDI file standard.

The data for the custom meta event is specified as a blob object.

### System exclusive events

System exclusive events are special MIDI messages that are often used for device-specific configuration, among other things.

All MIDI messages are stored in standard MIDI files exactly as they are transmitted, except for system exclusive messages.  System exclusive messages in MIDI files are slightly different than how they are transmitted.

Part of the problem is that system exclusive messages may need delays within them to give the MIDI instrument time to store the data, but standard MIDI files have no concept of delaying part of a message.  Therefore, standard MIDI files split system exclusive messages up into separate packets and store the individual packets as events rather than the whole system exclusive message as an event.

The standard MIDI file format also uses the packet format to allow other types of MIDI messages, such as realtime messages, to be inserted in MIDI files that would not otherwise be allowed.

The MIDI module expects the system exclusive packets to be specified as blobs.  If a blob is non-empty and begins with the byte 0xF0, it is assumed by Infrared to be the starting packet of a system exclusive message.  In this case, the regular "sysex" format is used in the MIDI file.  The initial 0xF0 will be skipped in the blob and instead be implicitly present.

For all empty blobs and all blobs that begin with a byte other than 0xF0, it is assumed by Infrared to be something other than the starting packet of a system exclusive message.  In this case, the "escape" format will be used in the MIDI file, which includes the whole blob and does not have any implicit data bytes.

### Channel events

Channel events are the main kind of MIDI messages that define the performance.  There are three channel event formats:

1. Single-parameter events
2. Double-parameter events
3. Wide-parameter events

Single-parameter events take an event type, a MIDI channel number, and a value.  The event type is either Program Change or Channel Pressure (Aftertouch).  The channel number is in range 1 to 16 inclusive.  The value is in range 0 to 127 inclusive.

Double-parameter events take an event type, a MIDI channel number, an index, and a value.  The event type is either Note-Off, Note-On, Polyphonic Key Pressure (Aftertouch), or Control Change.  The channel number is in range 1 to 16 inclusive.  The index and value are both in range 0 to 127 inclusive.

For all double-parameter event types except Control Change, the index is a MIDI key number and the value is a velocity.  For Control Change, the index is a controller number and the value is the value to set.

Wide-parameter events take a MIDI channel number and a value.  No event type is required because the only wide-parameter event is Pitch Bend Change.  The value is in range 0 to 0x3fff inclusive.
