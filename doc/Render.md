# Infrared note rendering

This document describes how Infrared _renders_ notes by transforming NMF note events into MIDI messages.

See the separate documentation on timing systems for further information about quanta, subquanta, and the differences between NMF and MIDI timing.

See the separate documentation on graphs for the details of how graph objects are defined and used.

## NMF note events

Infrared receives all note definitions from an input Noir Music Format (NMF) file.  Each NMF note event has the following fields:

1. Time offset
2. Duration
3. Pitch
4. Articulation
5. Section
6. Layer

The _time offset_ defines a specific time point the start of the event is relative to.  For all measured events (everything but unmeasured grace notes), the time offset is the start of the note.  For unmeasured grace notes, the time offset is the beat the grace note is anchored to, and the grace note occurs sometime before this time offset.

The _duration_ defines the duration for measured notes or the pickup position for unmeasured grace notes.  If it is greater than zero, it is the notated length of the measured note.  If it is less than zero, it indicates the position of an unmeasured grace note:  -1 is the grace note immediately preceding the beat selected by the time offset, -2 is the grace note immediately preceding that, and so forth.  The special duration value of zero is reserved by NMF for cue events, though it is never actually generated by the `noir` notation program.

Both the time offset and positive durations are measured in integer units called _quanta._  NMF supports several definition of quanta, but Infrared only supports the quantum definition used by the `noir` notation program, which assigns 96 quanta to a notated quarter note.

The _pitch_ is a signed integer that counts the number of semitones away from middle C on an equal-tempered keyboard.  NMF requires pitches to be within range of an 88-key piano keyboard.

The _articulation_ is an integer in range 0 to 61 inclusive which is intended to capture note annotations such as staccato and legato marks.  However, NMF does not define the specific meanings of any particular articulations.

The _section_ and _layer_ assign notes to different logical regions within the NMF file.  There is a hierarchical relationship, where each section contains multiple layers.  The section roughly indicates regions of time within the composition, corresponding to the horizontal dimension in musical scores.  However, sections are allowed to overlap in time.  The layer roughly indicates what "voice" a particular event belongs to within a section, corresponding to the vertical axis of different staves in musical scores.

## Pipelines

A _pipeline_ is a method for assigning a specific kind of value with a specific note.  Infrared objects such as articulations, rulers, and graphs, as well as Infrared parameters such as MIDI channel, release velocity, and aftertouch enable are associated with NMF notes using pipelines.

Each pipeline starts with a _default value._  NMF note events that run through the pipeline are initially assigned the default value.  The pipeline then contains a sequence of zero or more _classifiers._  Each classifier determines whether or not the NMF note event being examined satisfies the classification.  If it does, then the classifier overwrites the value assigned to the NMF note with whatever value is defined by the classifier.  The value that remains at the end of the pipeline is the value that is assigned to the note by that pipeline.

Classifiers determine which NMF notes satisfy their criteria by using three _set objects._  A classifier therefore contains three set objects and the value that the classifier sets if satisfied.

A _set object_ is a set of unique integer values, each of which is greater than or equal to zero.  There are two kinds of sets.  In a _positive set,_ only a finite number of specified integer values are selected.  In a _negative set,_ every integer value zero or greater is selected, except for a finite number of specified integer values that are excluded.  Both positive and negative sets compress their finite values by collapsing sequential finite values into ranges specified only by their lower and upper boundaries.

The first set object in a classifier selects which NMF sections the classifier applies to.  The second set object in a classifier selects which NMF layers the classifier applies to.  The third set object in a classifier selects which NMF articulations the classifier applies to.  An NMF note satisfies a classifier only if its section is in the first set, its layer is in the second set, and its articulation is in the third set.

## Pipeline types

Infrared has the following pipelines:

1. Articulation pipeline
2. Ruler pipeline
3. Graph pipeline
4. Channel pipeline
5. Release velocity pipeline
6. Aftertouch flag pipeline

The default articulation is:

- __Multiplier:__ 1/1
- __Bumper:__ 8 subquanta (1 NMF quantum)
- __Gap:__ 0

The default ruler is:

- __Slot:__ 48 subquanta (NMF 1/64th note)
- __Gap:__ 0

The default graph has a constant value of 64, which is the "neutral" MIDI velocity.

The default MIDI channel is the first channel.

The default release uses Note-On events with a velocity of zero.

The default aftertouch enable flag value is disabled.

## Infrared note events

An Infrared note event has the following fields:

1. Event ID
2. Subquantum offset
3. Subquantum duration
4. MIDI key number
5. MIDI channel number
6. Graph object
7. Release velocity
8. Aftertouch flag

Each NMF note event is transformed into an Infrared note event using the following method.

The _event ID_ is a unique integer assigned to each event in sequential order according to the order in which events are defined in the NMF file.

The _subquantum offset_ is the absolute time offset in subquanta that the performance of the note begins.  It may be a negative value.  For NMF note events that are measured (not a grace note), the subquantum offset is merely the quantum time offset multiplied by eight.  For NMF note events that are unmeasured grace notes, the ruler pipeline is used to get a ruler object for the note event, and then the ruler is used to determine both the subquantum offset and subquantum duration, as described later.

The _subquantum duration_ is the absolute performance duration of the note in subquanta.  It must be greater than zero.  For NMF note events that are measured (not a grace note), the articulation pipeline is used to get an articulation for the note event, and then the articulation is used to transform the NMF duration in quanta into a performance duration in subquanta, as described in a later section.  For NMF note events that are unmeasured grace notes, the ruler pipeline is used to get a ruler object for the note event, which then determines both the subquantum offset and subquantum duration, as described later.  NMF note events with a duration of zero are discarded.

The _MIDI key number_ is determined by simply adding 60 to the NMF pitch.  The NMF pitch range is a subset of the MIDI key range, so there should never be range problems here.

The _MIDI channel number_ is determined by the channel pipeline.  It determines which MIDI channel the note is assigned to.

The _graph object_ is determined by the graph pipeline.  It determines the MIDI note-on velocity of the note.  It also determines the polyphonic aftertouch messages if the aftertouch flag is enabled for this event.

The _release velocity_ is determined by the release velocity pipeline.  It determines the note-off velocity for the note.  There is a special value that indicates a note-on message with a velocity of zero should be used for the release instead of a note-off message.  (This is allowed by the MIDI standard.)

The _aftertouch flag_ is determined by the aftertouch flag pipeline.  If enabled, the note event will generate polyphonic aftertouch messages to track changes in the graph object.  If disabled, the note event will not generate any polyphonic aftertouch messages.

## Articulations

_Articulations_ are defined by three fields:

1. Scale
2. Bumper
3. Gap

The _scale_ is a rational number that has a denominator of either 1, 2, 4, or 8 and a numerator that is an integer greater than zero and less than or equal to the denominator.  Rational numbers of equal value are equivalent, such that 1/2, 2/4, and 4/8 have exactly the same meaning.

The _bumper_ is an integer greater than zero.  The bumper is measured in _subquantum_ units, where there are exactly eight subquanta in a single NMF quantum.  (See the separate document on timing systems for further information.)

The _gap_ is an integer less than or equal to zero.  The gap is also measured in subquantum units.

A measured (non-grace) note from the NMF file has its notated duration transformed into the MIDI performance duration using the following method:

First, the notated duration is translated into subquantum units by multiplying the NMF duration by 8.

Second, the subquantum duration is multiplied by the scale.  (Dividing by the denominator of the scale will always yield an integer result because we multiplied each NMF duration by 8.)

Third, if the duration is less than the bumper, the duration is extended to the bumper duration.

Fourth, if the duration is greater than the notated duration reduced by the gap, the duration is shortened to the notated duration reduced by the gap.

Fifth, if the resulting duration is less than one subquantum unit, the resulting duration is set to one subquantum unit.

## Rulers

_Rulers_ are defined by two fields:

1. Slot
2. Gap

The _slot_ defines the total duration of the time slot unmeasured grace notes occupy.  The first grace note before the beat will occupy the first slot before the beat.  The second grace note before the beat will occupy the second slot before the beat, and so forth.  The slot must be an integer greater than zero, and it is measured in subquanta.

The _gap_ defines the amount of silence at the end of each slot, similar to the gap used in articulations.  The gap must be an integer number of subquanta less than or equal to zero.  Furthermore, when the slot duration is reduced by the gap, the result must be greater than zero.

Suppose there is a grace note before a beat.  The beat occurs at time offset _b_ (measured in subquanta) and the grace note index is _i_ which is an integer less than zero where -1 means the first grace note before the beat, -2 means the second grace note before the beat, and so forth.  If a grace timing with slot _s_ and gap _g_ is applied to this grace note, the grace note will be positioned at:

    g_offset = b + (i * s)
    g_dur    = s + g

In the Infrared sequence, it is acceptable for the computed grace note offset to be a negative time offset.  This will be automatically corrected during MIDI output, as described in the separate documentation about MIDI output.

## Keyboard process

Once we have a sequence of Infrared note events, the next step is to run the events through the _keyboard process._  The keyboard process may shorten certain performance durations and may drop certain note events.

The purpose of the keyboard process is to ensure that note events do not inappropriately overlap.  MIDI assumes the note events are describing key presses on a keyboard, with 16 separate channels.  Within each channel, on each keyboard key there should never be overlapping note events for that key.  However, it is acceptable for a note event on a specific key to end at the same time point that another note event on that key begins, because in the final MIDI sequence these events will not actually overlap.

The keyboard process begins by sorting all Infrared events first by MIDI channel, second by MIDI key, third by subquantum offset, fourth by subquantum duration in descending order, and fifth by event ID.

Next, for each sequence of notes where the channel, key, and subquantum offset are the same, the first event in the sequence is kept and all other events are discarded.  This means that when there are multiple notes starting at the same time on the same key on the same channel, the note with the longest duration will be kept and the others will be dropped.  When there are multiple notes with the longest duration, choose the one that is defined last in the NMF file.

Finally, for each sequence of notes sharing the same channel and key, go through the sequence and look for disallowed overlaps between a note and the next note.  When a note's duration goes beyond the start of the next note, shorten the note's duration until it ends at the same time the next note begins.

Once this process completes, all note events will be proper for keyboard performance and overlap is no longer a concern.

## MIDI process

Following the keyboard process, each remaining note event is then divided into the appropriate MIDI messages.  The MIDI messages are timed according to moment offsets, which is described in separate documentation about the MIDI output layer.

Each Infrared note event is split into a Note-On event, a Note-Off event, and optionally a sequence of Polyphonic Key Pressure events.  The Note-Off event might actually be a Note-On event with a velocity of zero.

The Note-On event occurs at the subquantum offset given in the Infrared event, converted to a moment offset with middle-of-moment moment part.  The MIDI channel and MIDI key number match the fields within the Infrared event.  The velocity is determined by a query to the graph object at the subquantum offset of the Infrared event, and this velocity must be in range 1 to 127 inclusive.

The Note-Off event occurs at the subquantum offset plus the subquantum duration, converted to a moment offset with start-of-moment moment part.  The MIDI channel and MIDI key number match the fields within the Infrared event.  The velocity is determined by the release velocity of the Infrared event.  If the release velocity has the special value, a Note-On event with a velocity of zero is used instead of a Note-Off event.

If the aftertouch enable flag is set for the Infrared event, then the tracking algorithm described in the graph documentation is used to generate Polyphonic Key Pressure (Aftertouch) events.  The tracking algorithm has its time range limited to the subquantum after the note-on event up to and including the subquantum before the note-off event.  The graph values must be in range 1 to 127 inclusive.  The moment part matches exactly whenever the values change in the graph that is being tracked.

Each MIDI message is then added to the moment buffer described in the MIDI output module documentation.
